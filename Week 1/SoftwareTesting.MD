# Software Testing
## What?

Software Testing means verifying that the actual software product matches expected requirements and ensuring that the software product is Defect-free. It involves (manual/automated) execution of software/system components to evaluate one or more properties of interest. *The purpose of software testing is to identify **errors, gaps or missing requirements** in contrast to actual requirements*.

## Why?

Properly tested software product ensures reliability, security and high performance which further results in time saving, cost effectiveness and **customer satisfaction.**

Testing is important because bugs could be expensive or even dangerous. Software bugs can potentially cause monetary and human losses. History is full of such examples.

### Benefits

+ **It is Cost-Effective:** Testing any IT project on time saves money in the long run, i.e. the sooner bugs are caught, the least it would cost to fix them.
+ **Security:** Testing removes risks and problems earlier.
+ **Product quality:** It is an essential requirement of any software product. Testing ensures a quality product is delivered to customers.
+ **Customer Satisfaction:** The main aim of any product is to give satisfaction to their customers. UI/UX Testing ensures the best user experience, it builds trust and guarantes revenue.

## Standard

As per ANSI/IEEE 1059 (https://ieeexplore.ieee.org/document/838043), Testing in Software Engineering is a process of evaluating a software product to find whether the current software product meets the required conditions or not. The testing process involves evaluating the features of the software product for requirements in terms of any missing requirements, bugs or errors, security, reliability and performance.

## Types

Software Testing is typically divided into 3 main categories:

+ Functional Testing
+ Non-Functional Testing
+ Maintenance

Here's a few testing types by category.

### Functional Testing

This category specialises in ensuring the quality of output. In order words, verifying that the UUT delivers the 'expected' results as outlined by the requirements, i.e. *doing QA on **what** is delivered*. In order words, verifying the **functions** of a UUT.

+ Unit Testing
+ Integration Testing
+ Systems Testing
+ UAT (User Acceptance Testing)

### Non-Functional Testing

This category focuses more so on the way outputs are delivered. Pressumably, a UUT works, so we *do QA on **how** the UUT performs its processes*. This helps identify vulnerabilities and opportunities for improvement. It also paints an image of the UUT's scalability and reliability under different scenarios.

+ Performance
+ Endurance
+ Load
+ Volume
+ Scalability
+ Usability

### Maintenance

This type of testing is done to ensure functionality stays intact across versions or simply to ensure that *things that we're working before don't **break** after major changes*.

+ Regression
+ Maintenance

## Testing strategies

+ **Unit Testing:** (Performed by the developer) This software testing basic approach aims to test the units that make up a program. It helps developers to know whether the individual unit of the code is working properly or not. *Breaks a big problem into small steps and ensures that each step works individually*.

+ **Integration Testing:** It focuses on the architecture of the software product. *Ensures he individual pieces fit together to produce desired outcomes*

+ **System testing:** In this method, your software is compiled as a whole and then tested as a whole. This strategy checks the functionality, security, portability, amongst other aspects.